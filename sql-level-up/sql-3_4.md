## [ DBMS와 실행 계획 ]
> 개발자는 SQL레벨까지만 다루고, 나머지는 DBMS가 읽어들여서 처리해준다.   
> 개발자는 데이터가 있는 곳, 접근하는 방법 등 모든 것을 DBMS에게 위임한다고 생각하면 이해하기 쉽다.   
> 따라서, RDB는 데이터 접근을 위한 절차(HOW)를 모두 시스템에 이양했다. 이렇게 하는 것이 비즈니스 전체의 생산성을 향상시키기 때문이다.   
> 그럼에도 우리는 절차(HOW)를 이해해야 한다. 이를 의식하지 않고 사용하면, '성능 문제'가 발생할 수 있기 때문이다.    
> RDB가 숨기고 있는 내부 절차를 들여다봐야, 제대로 된 성능 개선과 적절한 SQL을 사용할 수 있다.

### 입력받은 SQL 구문을 처음 읽어들이는 '쿼리 평가 엔진'에 대해 알아보자.
쿼리 처리는 크게 1.파서 -> 옵티마이저(2. 플랜 생성 3. 비용 평가) -> 4. 카탈로그 매니저 5. 플랜 평가 로 이루어진다.
1. 파서
    - 이름 그대로 parse(구문 분석)하는 것이다. 컴파일 에러가 발생할 수 있다.
    - SQL 구문을 정형적인 형식으로 변환해준다.
2. 옵티마이저 ( DBMS 두뇌의 핵심 )
    - 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서 선택 가능한 많은 실행 계획을 작성(2.플랜 생성)하고   
    이들의 비용을 연산(3.비용 평가)한다.
3. 카탈로그 매니저
    - 옵티마이저에게 중요한 정보(테이블 또는 인덱스의 통계 정보)를 제공하는 역할을 수행한다.
      - 실제로 각 테이블의 레코드 수, 각 테이블의 필드 수와 필드 크기, 필드의 카디널리티(값의 개수), 필드값의 히스토그램(분포), 필드 내부 NULL 수, 인덱스 정보 등이 포함된다.
    - 갱신 처리(테이블에 삽입/수정/삭제)가 수행될 때, 카탈로그 정보가 갱신되지 않는다면, 옵티마이저는 오래된 정보를 바탕으로 실행 계획을 세우게 된다. -> 잘못된 계획을 세우게 된다.
      - 실제로 MySQL에서는 `ANALYZE TABLE [스키마 이름][테이블 이름];` 으로 통계 정보 갱신 명령어를 지원한다.
4. 플랜 평가
    - 옵티마이저의 실행 계획을 받아 최적의 실행 결과를 선택하는 역할을 수행한다. 
    - DBMS는 실행 계획을 절차적인 코드로 변환해, 데이터 접근을 수행한다.

## [ 실행 계획이 SQL 구문의 성능을 결정한다. ]
### 테이블 풀 스캔의 실행 계획
```sql
EXPLAIN
SELECT * FROM SHOPS;
```
모든 DBMS의 실행 계획에 포함된 내용은 다음과 같다.
- 조작 대상 객체(테이블 이외에도 인덱스, 파티션, 시퀀스처럼 SQL구문으로 조작할 수 있는 모든 객체)
  - Shops라는 테이블을 대상으로 조회를 했다면, on 이라는 글자 뒤에 shops 또는 Name 필드에 shops 라고 표시된다.
- 객체에 대한 조작의 종류
  - PostgreSQL : Seq Scan(순차적인 접근)
  - Oracle : Operation - TABLE ACCESS FULL(테이블 풀스캔)
- 조작 대상이 되는 레코드 수(ROWS)
  - 보통 Row라는 항목에 출력된다. 
  - 여기서 주의할 점은, 카탈로그 매니저로부터 얻은 '통계 정보'만 참고해 옵티마이저가 실행 계획을 만들기 때문에, 실제 테이블의 현재 상황과는 다른 결과가 나올 수 있다.    
  - 위에서도 언급한 내용이지만, 카탈로그 정보가 갱신되어야, 가장 최신화된 정보를 반영해 옵티마이저를 실행할 수 있다.

### 테이블 인덱스 스캔의 실행 계획
```sql
SELECT * FROM SHOPS
WHERE SHOP_ID = '00050';
```
Rows가 1로 바뀐다. 
- 접근 대상은 반드시 레코드 하나이다. (WHERE 에서 기본 키를 통해 하나만 지정했기 때문)
- TABLE ACCESS BY INDEX ROWID | SHOPS     
- INDEX UNIQUE SCAN | PK_SHOPS

### 테이블 결합의 실행 계획
shops 테이블과 reservations(예약 관리)테이블을 JOIN 해서 가져온다.
```sql
SELECT SHOP_NAME 
FROM SHOPS S INNER JOIN RESERVATIONS R 
ON S.shop_id = R.shop_id;
```
결합에 필요한 사용 알고리즘은 다음과 같다.
- Nested Loops
  - 한 쪽 테이블(SHOPS)를 읽으면서, ON 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식이다.
  - 마치 이중 반복문처럼 구현되기 때문에, Nested라는 이름이 붙었다.
- Sort Merge
  - 결합 전에 전처리로 '정렬'을 수행(워킹 메모리 사용)한다. 결합 키(shop_id)로 레코드를 정렬한 후 두 개의 테이블을 결합한다.
- Hash
  - 결합 키값을 '해시값'으로 매핑하는 방법이다. 해시테이블을 만들 때, 마찬가지로 워킹 메모리 영역을 사용한다. 

### 실행 계획은 일반적으로 '트리 구조'이다.
- 결합 전에 테이블 접근이 먼저 실행된다. 
  - Seq Scan(테이블 풀 스캔)을 통해 Reservations 를 스캔한다.
  - Index Scan(인덱스 스캔, shop_id)을 통해 Shops 를 스캔한다. 